// this deals with desugarDecr and desugarIncr
// notes:
// 1. I forgot the CVarRefExpr class, see it in "ast-test2.grammar"
// 2. This takes quite long to solve (>5m?), see "memory-bug.grammar" to reproduce the same issue (tool takes long to create examples).


traversal fuse {
    case CProgram {
        iterate first_function { recur first_function; }
    }
    case CFunction {
        iterate first_statement { recur first_statement; }
        iterate next { recur next; }
    }

    // assignment series
    case CAssignStmt {
        ??;
        recur assigned_expr;
        iterate next { recur next; }
    }
    case CIncrStmt {
        ??;
        recur assigned_expr;
        iterate next { recur next; }
    }
    case CDecrStmt {
        ??;
        recur assigned_expr;
        iterate next { recur next; }
    }
    case CIfStmt {
        ??;
        recur condition;
        iterate then_first_statement { recur then_first_statement; }
        iterate else_first_statement { recur else_first_statement; }
        iterate next { recur next; }
    }
    case CNullStmt {
        ??;
        iterate next { recur next; }
    }

    // expression series
    case CConstantExpr {
    }
    case CBinaryExpr {
        ??;
        ??;
        recur lhs;
        recur rhs;
    }
}

// ============================= //
// ========== Program ========== //
// ============================= //

interface Program {
    
}
class CProgram : Program {
    children {
        first_function : [Function];
    }
    rules {
    }
}

// ============================== //
// ========== Function ========== //
// ============================== //

interface Function {
    
}
class CFunction : Function {
    children {
        next : [Function];
        first_statement : [Statement];
    }
    rules {
    }
}

// =============================== //
// ========== Statement ========== //
// =============================== //
// desugarDecr will change CDecrStmt to CAssignStmt
// desugarInc will change CIncrStmt to CAssignStmt

interface Statement {
    // specific for CAssignStmt, CIncrStmt, CDecrStmt
    // corresponds to `int VarId` in `VarRefExpr *Id`
    // if it's CIfStmt or CNullStmt, this value should be null
    input var_id : int;

    // 0: CAssignStmt, 1: CIncrStmt, 2: CDecrStmt, 3: CIfStmt, others: CNullStmt
    output final_stmt_type : int;
}

class CAssignStmt : Statement {
    children {
        assigned_expr : Expression; // Expression
        next : [Statement];
    }
    rules {
        self.final_stmt_type := 0;
        assigned_expr.is_null := !true;
        assigned_expr.is_special_expr := !true;
        assigned_expr.final_lhs_var_id := null();
        assigned_expr.final_rhs_value := null();
        assigned_expr.final_operator := null();
    }
}
class CIncrStmt : Statement {
    children {
        assigned_expr : Expression; // deactivated by default for this type
        next : [Statement];
    }
    rules {
        self.final_stmt_type := 0; // change to CAssignStmt
        assigned_expr.is_null := !true;
        assigned_expr.is_special_expr := true;
        assigned_expr.final_lhs_var_id := self.var_id;
        assigned_expr.final_rhs_value := 1;
        assigned_expr.final_operator := 1; // plus
    }
}
class CDecrStmt : Statement {
    children {
        assigned_expr : Expression; // deactivated by default for this type
        next : [Statement];
    }
    rules {
        self.final_stmt_type := 0; // change to CAssignStmt
        assigned_expr.is_null := !true;
        assigned_expr.is_special_expr := true;
        assigned_expr.final_lhs_var_id := self.var_id;
        assigned_expr.final_rhs_value := 1;
        assigned_expr.final_operator := 0; // minus
    }
}
class CIfStmt : Statement {
    children {
        condition : Expression;
        then_first_statement : [Statement];
        else_first_statement : [Statement];
        next : [Statement];
    }
    rules {
        self.final_stmt_type := 3;
        condition.is_null := !true;
        condition.is_special_expr := !true;
        condition.final_lhs_var_id := null();
        condition.final_rhs_value := null();
        condition.final_operator := null();
    }
}
class CNullStmt : Statement {
    children {
        next : [Statement];
    }
    rules {
        self.final_stmt_type := 4;
    }
}


// ================================ //
// ========== Expression ========== //
// ================================ //

interface Expression {
    output is_null : bool;

    // special attributes for desugarDecr
    // the desugarDecr method converts C?Expr in DecrStmt to a special CBinaryExpr 
    // with no nested children, i.e., 
    // whose lhs is a var, and rhs is a constant 1.
    output is_special_expr : bool; // trigger for the following attributes
    output final_lhs_var_id : int;
    output final_rhs_value : int; 
    output final_operator : int; // 0: minus, 1: plus, others: others
}
class CBinaryExpr : Expression {
    children {
        // for binary expression, lhs and rhs *must* exist
        lhs : Expression;
        rhs : Expression;
    }
    rules {
        lhs.is_null :=
            if self.is_special_expr then
                true
            else
                !true;
        lhs.is_special_expr := !true;
        lhs.final_lhs_var_id := null();
        lhs.final_rhs_value := null();
        lhs.final_operator := null();

        rhs.is_null := 
            if self.is_special_expr then
                true
            else
                !true;
        rhs.is_special_expr := !true;
        rhs.final_lhs_var_id := null();
        rhs.final_rhs_value := null();
        rhs.final_operator := null();
    }
}
class CConstantExpr : Expression {
    children {
    }
    rules {
    }
}


// synthesized traversal:
//
// traversal fuse {
//   case CProgram {
//     iterate[left] first_function {
//       recur first_function;
//     }
//   }
//   case CFunction {
//     iterate[left] first_statement {
//       recur first_statement;
//     }
//     iterate[left] next {
//       recur next;
//     }
//   }
//   case CAssignStmt {
//     eval assigned_expr.final_operator;
//     eval assigned_expr.is_special_expr;
//     eval assigned_expr.is_null;
//     eval assigned_expr.final_rhs_value;
//     eval self.final_stmt_type;
//     eval assigned_expr.final_lhs_var_id;
//     recur assigned_expr;
//     iterate[left] next {
//       recur next;
//     }
//   }
//   case CIncrStmt {
//     eval assigned_expr.final_lhs_var_id;
//     eval assigned_expr.is_null;
//     eval self.final_stmt_type;
//     eval assigned_expr.final_operator;
//     eval assigned_expr.is_special_expr;
//     eval assigned_expr.final_rhs_value;
//     recur assigned_expr;
//     iterate[left] next {
//       recur next;
//     }
//   }
//   case CDecrStmt {
//     eval assigned_expr.final_rhs_value;
//     eval assigned_expr.is_null;
//     eval assigned_expr.is_special_expr;
//     eval assigned_expr.final_lhs_var_id;
//     eval assigned_expr.final_operator;
//     eval self.final_stmt_type;
//     recur assigned_expr;
//     iterate[left] next {
//       recur next;
//     }
//   }
//   case CIfStmt {
//     eval condition.final_operator;
//     eval condition.final_lhs_var_id;
//     eval condition.is_special_expr;
//     eval self.final_stmt_type;
//     eval condition.is_null;
//     eval condition.final_rhs_value;
//     recur condition;
//     iterate[left] then_first_statement {
//       recur then_first_statement;
//     }
//     iterate[left] else_first_statement {
//       recur else_first_statement;
//     }
//     iterate[left] next {
//       recur next;
//     }
//   }
//   case CNullStmt {
//     eval self.final_stmt_type;
//     iterate[left] next {
//       recur next;
//     }
//   }
//   case CConstantExpr {

//   }
//   case CBinaryExpr {
//     eval lhs.final_rhs_value;
//     eval lhs.final_operator;
//     eval rhs.is_special_expr;
//     eval rhs.is_null;
//     eval rhs.final_lhs_var_id;
//     eval lhs.is_null;
//     eval rhs.final_rhs_value;
//     eval rhs.final_operator;
//     eval lhs.final_lhs_var_id;
//     eval lhs.is_special_expr;
//     recur lhs;
//     recur rhs;
//   }
// }