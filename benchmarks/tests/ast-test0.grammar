// this provides a *initial* skeleton for ast benchmark

traversal fuse {
    case CProgram {
    }
    case CFunction {
    }

    // assignment series
    case CAssignStmt {
    }
    case CIfStmt {
    }
    case CIncrStmt {
    }
    case CDecrStmt {
    }

    // expression series
    case CConstantExpr {
    }
    case CBinaryExpr {
    }
}

// ============================= //
// ========== Program ========== //
// ============================= //

interface Program {
    
}
class CProgram : Program {
    children {
        first_function : [Function];
    }
    rules {
    }
}

// ============================== //
// ========== Function ========== //
// ============================== //

interface Function {
    
}
class CFunction : Function {
    children {
        next : [Function];
        first_statement : [Statement];
    }
    rules {
    }
}

// =============================== //
// ========== Statement ========== //
// =============================== //

interface Statement {
    // specific for CAssignStmt, CIncrStmt, CDecrStmt
    // corresponds to `int VarId` in `VarRefExpr *Id`
    input var_id : int;
}

class CAssignStmt : Statement {
    children {
        assigned_expr : Expression; // Expression
        next : [Statement];
    }
    rules {
    }
}
class CIfStmt : Statement {
    children {
        condition : Expression;
        then_first_statement : [Statement];
        else_first_statement : [Statement];
        next : [Statement];
    }
    rules {
    }
}
class CIncrStmt : Statement {
    children {
        next : [Statement];
    }
    rules {

    }
}
class CDecrStmt : Statement {
    children {
        next : [Statement];
    }
    rules {

    }
}
class CNullStmt : Statement {
    children {
        next : [Statement];
    }
    rules {

    }
}


// ================================ //
// ========== Expression ========== //
// ================================ //

interface Expression {
}
class CConstantExpr : Expression {
    children {
    }
    rules {
    }
}
class CBinaryExpr : Expression {
    children {
        // for binary expression, lhs and rhs *must* exist
        lhs : Expression;
        rhs : Expression;
    }
    rules {
    }
}
