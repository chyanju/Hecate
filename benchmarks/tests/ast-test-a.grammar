// self.tupleSum = prev.val + self.val
// self.accumSum = self.val + next.accumSum + first.accumSum

// ideal traversal
traversal fuse {
    case RootInterface {
        ??;
        recur root;
    }
    case ForwardNodeInterface {
        iterate first { ??; recur first; }
        iterate next { ??; recur next; }
        ??;
    }
}

interface Root {
}
class RootInterface : Root {
    children {
        root : ForwardNode;
    }
    rules {
        root.prevVal := 0;
    }
}

interface ForwardNode {
    output tupleSum : int;
    output accumSum : int;

    output prevVal : int;
    input val : int;
    input dumb : int;
}
class ForwardNodeInterface : ForwardNode {
    children {
        next : [ForwardNode];
        first : [ForwardNode];
    }
    rules {
        
        next.prevVal := process(self.val,self.dumb);
        first.prevVal := 0;

        self.tupleSum := self.prevVal + self.val;
        self.accumSum := [0]{ next.accumSum : 0 } + [0]{ first.accumSum : 0 };
    }
}
