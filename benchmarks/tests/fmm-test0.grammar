// this tests the traversal step 2
// (notice) based on FMM definitions, step 2 does not have any explicit dependencies

traversal fuse {
    case CVirtualRoot {
        ??;
        recur root;
    }
    case CVertex {
        ??;
        iterate c1 { recur c1; }
        iterate c2 { recur c2; }
        iterate c3 { recur c3; }
        iterate c4 { recur c4; }
        recur data;
    }
    case CData {
        ??;
        iterate next { recur next; }
    }
}

interface VirtualRoot {
}

class CVirtualRoot : VirtualRoot {
    children { 
        root : Vertex; 
    }
    rules {
    }
}

interface Vertex {
    input box.startX : int;
    input box.startY : int;
    input box.endX : int;
    input box.endY : int;

    output potential : int;
    output interactionList : VertexList;

    output x1 : int;
    output y1 : int;
}

class CVertex : Vertex {
    children {
        c1 : [Vertex];
        c2 : [Vertex];
        c3 : [Vertex];
        c4 : [Vertex];
        data : Data;
    }
    rules {
        self.x1 := ( self.box.startX + self.box.endX ) / 2;
        self.y1 := ( self.box.startY + self.box.endY ) / 2;

        self.potential := 
            0 + getPotential(
                self.x1, self.y1,
                data.mass,
                self.interactionList
            );

        // (notice) depend on self **inputs** (not outputs), no need to provide arguments
        // (notice) according to FMM, interaction list will not include children (does not overlap with children list)
        self.interactionList := getInteractionList(); 
    }
}

interface Data {
    input mass : int;
    input potential : int;
    input coordX : int;
    input coordY : int;
}
class CData : Data {
    children {
        next : [Data];
    }
    rules {

    }
}