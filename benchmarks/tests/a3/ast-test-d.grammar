// testing the following
// - constant folding: only applies on expression level
// - constant propagation: assignment generates rules, but apply on expressions; rules are not shared between functions

traversal fuse {
    case CProgram {
        iterate first_function { recur first_function; }
    }
    case CFunction {
        iterate first_statement { recur first_statement; }
        iterate next { recur next; }
    }

    // assignment series
    case AssignmentStatement {
        recur assigned_expr;
        ??;
    }
    case IfStatement {
        recur condition;
        iterate then_first_statement { recur then_first_statement; }
        iterate else_first_statement { recur else_first_statement; }
        ??;
    }
    case NopStatement {
        ??;
    }
    case IncrStatement {
        ??;
    }
    case DecrStatement {
        ??;
    }

    // expression series
    case ConstantExpression {
        ??;
    }
    case BinaryExpression {
        recur lhs;
        recur rhs;
        ??;
    }
    case VarRefExpression {
        ??;
    }
}

// ============================= //
// ========== Program ========== //
// ============================= //

interface Program {
    
}
class CProgram : Program {
    children {
        first_function : [Function];
    }
    rules {
    }
}

// ============================== //
// ========== Function ========== //
// ============================== //

interface Function {
    
}
class CFunction : Function {
    children {
        next : [Function];
        first_statement : [Statement];
    }
    rules {
        first_statement.original_constant_propagation_info := empty_constant_propagation_info();
    }
}

// =============================== //
// ========== Statement ========== //
// =============================== //

interface Statement {
    // 0: ASSIGNMENT, 1: IF, 2: NOP, 3: INCR, 4(others): DECR
    output statement_type : int;

    // ==== based on different statement_type, the following attributes are enabled accordingly ==== //
    // 0: ASSIGNMENT, 3: INCR, 4(others): DECR
    input var_id : int; // expanded LHS id, originally it's a VarRefExpression

    // constant propagation exclusive
    output original_constant_propagation_info : int;
    output final_constant_propagation_info : int;
}
class AssignmentStatement : Statement {
    children {
        assigned_expr : Expression;
    }
    rules {
        self.statement_type := 0;
        self.final_constant_propagation_info := 
            if assigned_expr.final_expression_type == 0 then
                add_constant_propagation_info( self.original_constant_propagation_info, assigned_expr.final_value, self.var_id )
            else
                self.original_constant_propagation_info;

        assigned_expr.constant_propagation_info := self.final_constant_propagation_info;
    }
}
class IfStatement : Statement {
    children {
        condition : Expression;
        then_first_statement : [Statement];
        else_first_statement : [Statement];
    }
    rules {
        self.statement_type := 1;
        self.final_constant_propagation_info := self.original_constant_propagation_info;
        condition.constant_propagation_info := self.final_constant_propagation_info;
        then_first_statement.original_constant_propagation_info := self.final_constant_propagation_info;
        else_first_statement.original_constant_propagation_info := self.final_constant_propagation_info;
    }
}
class NopStatement : Statement {
    children {
    }
    rules {
        self.statement_type := 2;
        self.final_constant_propagation_info := self.original_constant_propagation_info;
    }
}
class IncrStatement : Statement {
    children {
    }
    rules {
        self.statement_type := 3;
        self.final_constant_propagation_info := self.original_constant_propagation_info;
    }
}
class DecrStatement : Statement {
    children {
    }
    rules {
        self.statement_type := 4;
        self.final_constant_propagation_info := self.original_constant_propagation_info;
    }
}

// ================================ //
// ========== Expression ========== //
// ================================ //

interface Expression {
    // 0: CONSTANT, 1: BINARY, 2(others): VARREF
    // possible conversions:
    // - BINARY -> CONSTANT (constant folding)
    //     - original_expression_type -> final_expression_type
    //     - value -> final_value
    // - VARREF -> CONSTANT (constant propagation)
    //     - original_expression_type -> final_expression_type
    //     - value -> final_value
    output original_expression_type : int;
    output final_expression_type : int; 

    // ==== based on different expression_type, the following attributes are enabled accordingly ==== //
    // 0: CONSTANT
    input value : int;
    output final_value : int;

    // 1: BINARY
    // binary also has structural LHS and RHS
    input operator : int; // 0: add, 1(others): subtract

    // 2: VARREF
    input var_id : int;

    // constant folding exclusive
    output need_constant_folding : bool;

    // constant propagation exclusive
    output need_constant_propagation : int;
    output constant_propagation_info : int;
}
class ConstantExpression : Expression {
    children {
    }
    rules {
        self.original_expression_type := 0;
        self.need_constant_folding := !true;
        self.need_constant_propagation := !true;
        self.final_expression_type := 0;
        self.final_value := self.value;
    }
}
class BinaryExpression : Expression {
    children {
        // for binary expression, lhs and rhs *must* exist
        lhs : Expression;
        rhs : Expression;
    }
    rules {
        self.original_expression_type := 1;

        self.need_constant_folding := 
            if lhs.final_expression_type == 0 && rhs.final_expression_type == 0 then
                true
            else
                !true;

        self.need_constant_propagation := !true;
        lhs.constant_propagation_info := self.constant_propagation_info;
        rhs.constant_propagation_info := self.constant_propagation_info;

        self.final_expression_type := 
            if self.need_constant_folding then
                0
            else
                1;

        self.final_value := 
            if self.need_constant_folding then
                if self.operator == 0 then
                    lhs.final_value + rhs.final_value
                else
                    lhs.final_value - rhs.final_value
            else
                self.value;
    }
}
class VarRefExpression : Expression {
    children {
    }
    rules {
        self.original_expression_type := 2;
        self.need_constant_folding := !true;

        self.need_constant_propagation :=
            if has_id(self.constant_propagation_info,self.var_id) then
                true
            else
                !true;

        self.final_expression_type := 
            if self.need_constant_propagation then
                0
            else
                2;

        self.final_value := 
            if self.need_constant_propagation then
                get_value_by_id(self.constant_propagation_info,self.var_id)
            else
                self.value;
    }
}
