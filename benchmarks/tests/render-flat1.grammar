// this deals with ResolveFlexWidths (post-order)
// this also deals with ResolveRelativeWidth (pre-order)
// run with: ./run.rkt --root Document fuse benchmarks/tests/render-flat1.grammar
// 
//
// hints:
// 1. foldl expression should be placed into iterate { ??; }

traversal fuse {
    case CDocument {
        iterate page_list { recur page_list; }
    }
    case CPage {
        iterate horiz_list { recur horiz_list; ??; }
        ??;
    }
    case CHorizontalContainer {
        iterate element_list { recur element_list; ??; }
        ??;
    }
    case CNormalElement {
        ??;
    }
    case CVerticalContainer {
        iterate horiz_list { recur horiz_list; ??; }
        ??;
    }
}

// ============================= //
// ========== Program ========== //
// ============================= //

interface Document {
    
}
class CDocument : Document {
    children {
        page_list : [Page];
    }
    rules {
    }
}

interface Page {
    // normal shared data
    input width : int;
    input w_mode : int; // 0: ABS, 1: REL, 2: FLEX, others: ?
    input rel_width : int;

    output final0_width : int; // after ResolveFlexWidths
    output horiz_list_max_width : int; // // after ResolveFlexWidths

    output final1_width : int; // after ResolveRelativeWidth
}
class CPage : Page {
    children {
        horiz_list : [HorizontalContainer]; // 0 or 1
    }
    rules {
        // ==== ResolveFlexWidths ==== //
        self.horiz_list_max_width := foldl default() .. max( @{self.horiz_list_max_width}, horiz_list.final0_width );
        self.final0_width :=
            if self.w_mode == 2 then
                self.horiz_list_max_width
            else
                self.width;

        // ==== ResolveRelativeWidth ==== //
        self.final1_width := self.final0_width; // don't care
        horiz_list.final1_width :=
            if horiz_list.w_mode == 1 then
                horiz_list.rel_width * self.final1_width
            else
                horiz_list.final0_width;
    }
}

interface HorizontalContainer {
    // normal shared data
    input width : int;
    input w_mode : int; // 0: ABS, 1: REL, 2: FLEX, others: ?
    input rel_width : int;

    output final0_width : int; // after ResolveFlexWidths
    output element_list_max_width : int;
    output element_list_accumulated_width : int;

    output final1_width : int; // after ResolveRelativeWidth
}
class CHorizontalContainer : HorizontalContainer {
    children {
        element_list : [Element]; // 0 or 1
    }
    rules {
        // ==== ResolveFlexWidths ==== //
        self.element_list_max_width := foldl default() .. max( @{self.element_list_max_width}, element_list.final0_width );
        self.element_list_accumulated_width := foldl default() .. @{self.element_list_accumulated_width} + element_list.final0_width;
        self.final0_width :=
            if self.w_mode == 2 then
                self.element_list_accumulated_width
            else
                self.width;

        // ==== ResolveRelativeWidth ==== //
        element_list.final1_width :=
            if element_list.w_mode == 1 then
                element_list.rel_width * self.final1_width
            else
                element_list.final0_width;
    }
}

interface Element {
    // 0: TextBox, 1: List, 2: Image, 3: VerticalContainer
    // input element_type : int;

    // normal shared data
    input width : int;
    input w_mode : int; // 0: ABS, 1: REL, 2: FLEX, others: ?
    input rel_width : int;

    output final0_width : int; // after ResolveFlexWidths
    output horiz_list_max_width : int; // only for CVerticalContainer

    output final1_width : int; // after ResolveRelativeWidth
}
class CNormalElement : Element {
    children {
    }
    rules {
        // ==== ResolveFlexWidths ==== //
        self.final0_width := self.width; // don't care
        self.horiz_list_max_width := null(); // don't care
    }
}
class CVerticalContainer : Element {
    children {
        horiz_list : [HorizontalContainer]; // exclusive for CVerticalContainer
    }
    rules {
        // ==== ResolveFlexWidths ==== //
        self.horiz_list_max_width := foldl default() .. max( @{self.horiz_list_max_width}, horiz_list.final0_width );
        self.final0_width := 
            if self.w_mode == 2 then
                // this corresponds to self.horiz_list_max_width
                self.horiz_list_max_width
            else
                self.width;

        // ==== ResolveRelativeWidth ==== //
        horiz_list.final1_width :=
            if horiz_list.w_mode == 1 then
                horiz_list.rel_width * self.final1_width
            else
                horiz_list.final0_width;
    }
}























