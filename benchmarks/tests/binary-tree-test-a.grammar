// BinaryTree example of Grafter
// this example only deals with insert
// every insertion is provided as an input to the RootInterface
// (notice) assume every insert query can be fulfilled (the tree is big enough so you can always find a spot)

// ideal traversal
traversal fuse {
    case RootInterface {
        ??;
        recur root;
    }
    case NodeInterface {
        ??;
        iterate l { ??; recur l; }
        iterate r { ??; recur r; }
    }
}


interface Root {
    // the user input the value to insert from the root node
    input valToInsert : int;
}
class RootInterface : Root {
    children {
        root : Node;
    }
    rules {
        root.valToInsert := self.valToInsert;
    }
}


interface Node {

    // preset constants
    output constantNull : int;
    output constantTrue : bool;
    output constantFalse : bool;
    
    // inherit the input command from parent
    output valToInsert : int;

    // existing value stored in the current node
    // notice that this comes from the user (structural info)
    input valToStore : int;

    // the actual value stored after eval
    // this is computed using valToInsert and valToStore
    // i.e.,
    // if the node has value already specified structurally
    // then it should pass the valToInsert to its corresponding child
    output valStored : int; 

    // easy flag to tell whether the valStored should be set to valToInsert or valToStore
    // true: valToInsert
    // false: valToStore
    // (notice) if we don't insert here (false), it means
    // 1. we don't have anything to insert, or
    // 2. there's already a valToStore
    output insertHere : bool;
}
class NodeInterface : Node {
    children {
        l : [Node];
        r : [Node];
    }
    rules {

        self.constantNull := -9999;
        self.constantTrue := true;
        self.constantFalse := !self.constantTrue;

        self.insertHere :=
            if self.valToInsert == self.constantNull then
                self.constantFalse
            else
                if self.valToStore == self.constantNull then
                    self.constantTrue
                else
                    // (notice) special case: equiv. of insert and store
                    if self.valToStore == self.valToInsert then
                        self.constantTrue
                    else
                        self.constantFalse;


        self.valStored := 
            if self.insertHere then
                self.valToInsert
            else
                self.valToStore;

        l.valToInsert := 
            if self.insertHere then
                self.constantNull
            else
                // (notice) see comments of insertHere
                if self.valToInsert == self.constantNull then
                    self.constantNull
                else
                    if self.valToInsert <= self.valToStore then
                        self.valToInsert
                    else
                        self.constantNull;

        r.valToInsert := 
            if self.insertHere then
                self.constantNull
            else
                // (notice) see comments of insertHere
                if self.valToInsert == self.constantNull then
                    self.constantNull
                else
                    if self.valToInsert > self.valToStore then
                        self.valToInsert
                    else
                        self.constantNull;

    }
}