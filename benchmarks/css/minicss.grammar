traversal pre_order {
  BlockFlow { visit; loop flow { visit }; visit; loop flow { recur } }
  ImageFlow { visit }
  InlineFlow { visit; loop text { visit }; visit; loop text { recur } }
  InlineText { }
}

traversal post_order {
  BlockFlow { loop flow { recur }; visit; loop flow { visit }; visit }
  ImageFlow { visit }
  InlineFlow { loop text { recur }; visit; loop text { visit }; visit }
  InlineText { }
}

traversal inter_pre_order {
  BlockFlow { visit; loop flow { visit; recur } }
  ImageFlow { visit }
  InlineFlow { visit; loop text { visit; recur } }
  InlineText { }
}

traversal inter_post_order {
  BlockFlow { loop flow { recur; visit }; visit }
  ImageFlow { visit }
  InlineFlow { loop text { recur; visit }; visit }
  InlineText { }
}

traversal in_order {
  BlockFlow { visit; loop flow { visit; recur; visit }; visit }
  ImageFlow { visit }
  InlineFlow { visit; loop text { visit; recur; visit }; visit }
  InlineText { }
}

interface BaseFlow {
  input is_root : bool;
  input screenWidth : int;

  // Absolute position of this flow's border box
  output absX : int;
  output absY : int;

  // Relative position of this flow's border box (w.r.t. containing block)
  output relX : int;
  output relY : int;

  // Relative position of this flow's content box
  output boxX : int;
  output boxY : int;

  // Width and height of this flow's content box
  output boxWidth : int;
  output boxHeight : int;

  // Width and height of this flow's margin box
  output totalWidth : int;
  output totalHeight : int;

  output right : int;
  output bottom : int;

  output leastWidth : int;
  output relaxWidth : int;

  // Width of this flow's containing box
  output availWidth : int;
}

interface InlineBox {
  input linebreak : bool;
  input inlineWidth : int;
  input inlineHeight : int;
  input inlineAscent : int;

  output newline : bool;
  output topline : int; // [int]
  output baseline : int; // [int]
  output lineWidth : int;
  output lineHeight : int;
  output top : int;
  output posX : int;
  output posY : int;
  output right : int;
}

class DocumentFlow : BaseFlow {
  children {
    body: BaseFlow;
  }
  attributes {
    input screenHeight : int;
  }
  evaluation {
    self.absX := 0;
    self.absY := 0;
    self.relX := 0;
    self.relY := 0;
    self.boxX := 0;
    self.boxY := 0;
    self.boxWidth := self.screenWidth;
    self.boxHeight := self.screenHeight;
    self.totalWidth := self.boxWidth;
    self.totalHeight := self.boxHeight;
    self.right := self.totalWidth;
    self.bottom := self.totalHeight;
    self.leastWidth := body.leastWidth;
    self.relaxWidth := body.relaxWidth;

    body.absX := self.absX;
    body.absY := self.absY;
    body.relX := 0;
    body.relY := 0;
    body.right := body.totalWidth;
    body.bottom := body.totalHeight;
    body.availWidth := screenWidth;
  }
}

trait FrameFlow {
  attributes {
    // Width of content box (no margin) per style properties
    output autoWidth : int;
    output realWidth : int;

    // Dimensions of a block flow's box per style properties
    output intrinsWidth : int;
    output intrinsHeight : int;

    // Length of content boundary (padding+border) in each direction
    output boundWidth : int; // left+right
    output boundHeight : int; // top+bottom

    // Length of content frame (margin+padding+border) in each direction
    output frameWidth : int; // left+right
    output frameHeight : int; // top+bottom

    // Width of margin frame per style properties (non-automatic)
    output marginLeft : int;
    output marginRight : int;
    output marginWidth : int;

    // Style: height
    input blockHeight_auto : bool; // automatic?
    input blockHeight_rel : bool; // relative?
    input blockHeight_len : int; // percentage if relative else absolute units

    // Style: width
    input blockWidth_auto : bool; // automatic?
    input blockWidth_rel : bool; // relative?
    input blockWidth_len : int; // percentage if relative else absolute units

    // Style: margin-top
    input marginTop_auto : bool; // automatic?
    input marginTop_rel : bool; // relative?
    input marginTop_len : int; // percentage if relative else absolute units

    // Style: margin-bottom
    input marginBottom_auto : bool; // automatic?
    input marginBottom_rel : bool; // relative?
    input marginBottom_len : int; // percentage if relative else absolute units

    // Style: margin-left
    input marginLeft_auto : bool; // automatic?
    input marginLeft_rel : bool; // relative?
    input marginLeft_len : int; // percentage if relative else absolute units

    // Style: margin-right
    input marginRight_auto : bool; // automatic?
    input marginRight_rel : bool; // relative?
    input marginRight_len : int; // percentage if relative else absolute units

    // Layout: margin widths
    output mt : int; // top
    output mb : int; // bottom
    output ml : int; // left
    output mr : int; // right

    // Style: padding-top
    input paddingTop_rel : bool; // relative?
    input paddingTop_len : int; // percentage if relative else absolute units

    // Style: padding-bottom
    input paddingBottom_rel : bool; // relative?
    input paddingBottom_len : int; // percentage if relative else absolute units

    // Style: padding-left
    input paddingLeft_rel : bool; // relative?
    input paddingLeft_len : int; // percentage if relative else absolute units

    // Style: padding-right
    input paddingRight_rel : bool; // relative?
    input paddingRight_len : int; // percentage if relative else absolute units

    // Layout: padding widths
    output pt : int; // top
    output pb : int; // below
    output pl : int; // left
    output pr : int; // right

    // Style: border-top-width
    input borderTop_len : int;

    // Style: border-bottom-width
    input borderBottom_len : int;

    // Style: border-left-width
    input borderLeft_len : int;

    // Style: border-right-width
    input borderRight_len : int;

    // Layout: border widths
    output bt : int; // top
    output bb : int; // bottom
    output bl : int; // left
    output br : int; // right
  }
  evaluation {
    intrinsWidth :=
      blockWidth_auto ?
        availWidth :
        (blockWidth_rel ? (blockWidth_len * availWidth / 100) : blockWidth_len);
    intrinsHeight := (blockHeight_auto || blockHeight_rel) ? 0 : blockHeight_len;

    pt := paddingTop_rel ? (paddingTop_len * availWidth / 100) : paddingTop_len;
    pb := paddingBottom_rel ? (paddingBottom_len * availWidth / 100) : paddingBottom_len;
    pl := paddingLeft_rel ? (paddingLeft_len * availWidth / 100) : paddingLeft_len;
    pr := paddingRight_rel ? (paddingRight_len * availWidth / 100) : paddingRight_len;

    bt := borderTop_len;
    bb := borderBottom_len;
    bl := borderLeft_len;
    br := borderRight_len;

    boundWidth := pl + pr + bl + br;
    boundHeight := pt + pb + bt + bb;

    marginWidth := availWidth - boundWidth - intrinsWidth;

    marginLeft := marginLeft_rel ? (marginLeft_len * availWidth / 100) : marginLeft_len;
    marginRight := marginRight_rel ? (marginRight_len * availWidth / 100) : marginRight_len;

    mt :=
      marginTop_auto ?
        0 :
        (marginTop_rel ? (marginTop_len * availWidth / 100) : marginTop_len);
    mb :=
      marginBottom_auto ?
        0 :
        (marginBottom_rel ? (marginBottom_len * availWidth / 100) : marginBottom_len);
    ml :=
      !marginLeft_auto ?
        marginLeft :
        (blockWidth_auto ?
          0 :
          (marginRight_auto ? (marginWidth / 2) : (marginWidth - marginRight)));
    mr :=
      !marginRight_auto && (blockWidth_auto || marginLeft_auto) ?
        marginRight :
        (blockWidth_auto ?
          0 :
          (marginLeft_auto ? (marginWidth / 2) : (marginWidth - marginLeft)));

    frameWidth := ml + mr + boundWidth;
    frameHeight  := mt + mb + boundHeight;

    autoWidth :=
      leastWidth < availWidth ? (relaxWidth < availWidth ? relaxWidth : availWidth) : leastWidth;

    realWidth :=
      is_root ? screenWidth : (blockWidth_auto ? (autoWidth - frameWidth) : intrinsWidth);
  }
}

class BlockFlow (FrameFlow) : BaseFlow {
  children {
    flow : [BaseFlow];
  }
  attributes {
    output boxWidth_inner : int;
    output boxHeight_inner : int;

    output leastWidth_inner : int;
    output relaxWidth_inner : int;
  }
  evaluation {
    loop flow {
      boxHeight_inner := fold 0 .. self$-.boxHeight_inner + flow$i.totalHeight;
      boxWidth_inner := fold 0 .. self$-.boxWidth_inner + flow$i.totalWidth;

      leastWidth_inner :=
        fold intrinsWidth ..
          self$-.leastWidth_inner < flow$i.leastWidth ?
            flow$i.leastWidth :
            self$-.leastWidth_inner;
      relaxWidth_inner :=
        fold intrinsWidth ..
          self$-.relaxWidth_inner < flow$i.relaxWidth ?
            flow$i.relaxWidth :
            self$-.relaxWidth_inner;

      flow.bottom := fold pt + bt .. flow$-.bottom + flow$i.totalHeight;
      flow.right := flow$i.totalWidth + pl + bl;

      flow.relX := flow$i.right - flow$i.totalWidth;
      flow.relY := flow$i.bottom - flow$i.totalHeight;

      flow.absX := flow$i.relX + absX + ml;
      flow.absY := flow$i.relY + absY + mt;

      flow.availWidth := realWidth;
    }

    leastWidth := leastWidth_inner + frameWidth;
    relaxWidth := (intrinsWidth == 0 ? relaxWidth_inner : intrinsWidth) + frameWidth;

    boxX := relX + ml;
    boxY := relY + mt;

    boxWidth :=  is_root ? screenWidth : realWidth + boundWidth;
    boxHeight := (intrinsHeight == 0 ? boxHeight_inner : intrinsHeight) + boundHeight;

    totalWidth := boxWidth + ml + mr;
    totalHeight := boxHeight + mt + mb;
  }
}

class ImageFlow (FrameFlow) : BaseFlow {
    attributes {
        // Dimensions of raw image
        input imageWidth : int;
        input imageHeight : int;
    }
    evaluation {
        boxX := relX + ml;
        boxY := relY + mt;

        boxWidth := (intrinsWidth == 0 ? imageWidth : intrinsWidth) + boundWidth;
        boxHeight := (intrinsHeight == 0 ? imageHeight : intrinsHeight) + boundHeight;

        totalWidth := boxWidth + ml + mr;
        totalHeight := boxHeight + mt + mb;
    }
}

class InlineFlow : BaseFlow {
  children {
    text : [InlineBox];
  }
  evaluation {
    boxWidth := availWidth;
    boxX := relX;
    boxY := relY;
    relaxWidth := 0;
    leastWidth := 0;
    totalHeight := boxHeight;
    totalWidth := boxWidth;

    loop text {
      text.newline :=
        fold true .. (text$i.inlineWidth > text$-.lineWidth) || text$i.linebreak;

      text.lineWidth :=
        fold availWidth .. text$i.newline ? availWidth : (text$-.lineWidth - text$i.inlineWidth);

      text.topline :=
        fold 0 ..
          text$i.newline ?
            text$i.inlineAscent :
            (text$-.topline < text$i.inlineAscent ? text$i.inlineAscent : text$-.topline);

      text.baseline := fold 0 .. text$i.newline ? text$-.topline : text$-.baseline;
    }

    loop text {
      text.right :=
        fold 0 .. text$i.newline ? text$i.inlineWidth : (text$-.right + text$i.inlineWidth);
      text.top :=
        fold 0 .. text$i.newline ? (text$-.top + text$i.lineHeight) : text$-.top;

      text.posX := absX + text$i.right - text$i.inlineWidth;
      text.posY := absY + text$i.top + text$i.baseline - text$i.inlineAscent;

      text.lineHeight :=
        fold 0 ..
          text$i.newline ?
            text$i.inlineHeight :
            (text$-.lineHeight < text$i.inlineHeight ? text$i.inlineHeight : text$-.lineHeight);

      boxHeight := fold 0 .. self$-.boxHeight + text$i.lineHeight;
    }
  }
}

class InlineText : InlineBox { }
