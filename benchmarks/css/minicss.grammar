traversal pre_order {
  BlockFlow { visit; loop flow { visit }; visit; loop flow { recur } }
  ImageFlow { visit }
  InlineFlow { visit; loop text { visit }; visit; loop text { recur } }
  InlineText { }
}

traversal post_order {
  BlockFlow { loop flow { recur }; visit; loop flow { visit }; visit }
  ImageFlow { visit }
  InlineFlow { loop text { recur }; visit; loop text { visit }; visit }
  InlineText { }
}

traversal inter_pre_order {
  BlockFlow { visit; loop flow { visit; recur } }
  ImageFlow { visit }
  InlineFlow { visit; loop text { visit; recur } }
  InlineText { }
}

traversal inter_post_order {
  BlockFlow { loop flow { recur; visit }; visit }
  ImageFlow { visit }
  InlineFlow { loop text { recur; visit }; visit }
  InlineText { }
}

traversal in_order {
  BlockFlow { visit; loop flow { visit; recur; visit }; visit }
  ImageFlow { visit }
  InlineFlow { visit; loop text { visit; recur; visit }; visit }
  InlineText { }
}

interface BaseFlow {
  input is_root : bool;
  input screenWidth : int;

  // Absolute position of this flow's border box
  output absX : int;
  output absY : int;

  // Relative position of this flow's border box (w.r.t. containing block)
  output relX : int;
  output relY : int;

  // Relative position of this flow's content box
  output boxX : int;
  output boxY : int;

  // Width and height of this flow's content box
  output boxWidth : int;
  output boxHeight : int;

  // Width and height of this flow's margin box
  output totalWidth : int;
  output totalHeight : int;

  output right : int;
  output bottom : int;

  output intrinsMinWidth : int;
  output intrinsPrefWidth : int;

  // Width of this flow's containing box
  output availWidth : int;

  // XXX: Rendering
  //output makeList : DisplayList;
  //output display_list : DisplayList;
}

interface InlineBox {
  input linebreak : bool;
  input inlineWidth : int;
  input inlineHeight : int;
  input inlineAscent : int;

  output newline : bool;
  output topline : int; // [int]
  output baseline : int; // [int]
  output lineWidth : int;
  output lineHeight : int;
  output top : int;
  output posX : int;
  output posY : int;
  output right : int;

  // XXX: Rendering
  //input fragSpecific : SpecificFragmentInfo;
  //input fragStyle : Arc<ComputedValues>;
  //input fragNode : OpaqueNode;
}

trait FrameFlow {
  attributes {
    // Dimensions of a block flow's box as derived from style properties
    output intrinsWidth : int;
    output intrinsHeight : int;

    // Length of content boundary (padding+border) in each direction
    output boundWidth : int; // width (horizontal or left+right)
    output boundHeight : int; // height (vertical or top+bottom)

    // Length of content frame (margin+padding+border) in each direction
    output frameWidth : int; // width (horizontal or left+right)
    output frameHeight : int; // height (vertical or top+bottom)

    // Width of horizontal margins as derived from style properties (non-automatic)
    output marginLeft : int;
    output marginRight : int;
    output marginWidth : int;

    // Width for trimmed/overflown content
    output computedWidth : int;

    // Style: height
    input blockHeight_auto : bool; // automatic?
    input blockHeight_rel : bool; // relative?
    input blockHeight_len : int; // percentage if relative else absolute units

    // Style: width
    input blockWidth_auto : bool; // automatic?
    input blockWidth_rel : bool; // relative?
    input blockWidth_len : int; // percentage if relative else absolute units

    // Style: margin-top
    input marginTop_auto : bool; // automatic?
    input marginTop_rel : bool; // relative?
    input marginTop_len : int; // percentage if relative else absolute units

    // Style: margin-bottom
    input marginBottom_auto : bool; // automatic?
    input marginBottom_rel : bool; // relative?
    input marginBottom_len : int; // percentage if relative else absolute units

    // Style: margin-left
    input marginLeft_auto : bool; // automatic?
    input marginLeft_rel : bool; // relative?
    input marginLeft_len : int; // percentage if relative else absolute units

    // Style: margin-right
    input marginRight_auto : bool; // automatic?
    input marginRight_rel : bool; // relative?
    input marginRight_len : int; // percentage if relative else absolute units

    // Layout: margin widths
    output mt : int; // top
    output mb : int; // bottom
    output ml : int; // left
    output mr : int; // right

    // Style: padding-top
    input paddingTop_rel : bool; // relative?
    input paddingTop_len : int; // percentage if relative else absolute units

    // Style: padding-bottom
    input paddingBottom_rel : bool; // relative?
    input paddingBottom_len : int; // percentage if relative else absolute units

    // Style: padding-left
    input paddingLeft_rel : bool; // relative?
    input paddingLeft_len : int; // percentage if relative else absolute units

    // Style: padding-right
    input paddingRight_rel : bool; // relative?
    input paddingRight_len : int; // percentage if relative else absolute units

    // Layout: padding widths
    output pt : int; // top
    output pb : int; // below
    output pl : int; // left
    output pr : int; // right

    // Style: border-top-width
    input borderTop_len : int;

    // Style: border-bottom-width
    input borderBottom_len : int;

    // Style: border-left-width
    input borderLeft_len : int;

    // Style: border-right-width
    input borderRight_len : int;

    // Layout: border widths
    output bt : int; // top
    output bb : int; // bottom
    output bl : int; // left
    output br : int; // right
  }
  evaluation {
    intrinsWidth :=
      blockWidth_auto ?
        availWidth :
        (blockWidth_rel ? (blockWidth_len * availWidth / 100) : blockWidth_len);
    intrinsHeight := (blockHeight_auto || blockHeight_rel) ? 0 : blockHeight_len;

    pt := paddingTop_rel ? (paddingTop_len * availWidth / 100) : paddingTop_len;
    pb := paddingBottom_rel ? (paddingBottom_len * availWidth / 100) : paddingBottom_len;
    pl := paddingLeft_rel ? (paddingLeft_len * availWidth / 100) : paddingLeft_len;
    pr := paddingRight_rel ? (paddingRight_len * availWidth / 100) : paddingRight_len;

    bt := borderTop_len;
    bb := borderBottom_len;
    bl := borderLeft_len;
    br := borderRight_len;

    boundWidth := pl + pr + bl + br;
    boundHeight := pt + pb + bt + bb;

    marginWidth := availWidth - boundWidth - intrinsWidth;

    marginLeft := marginLeft_rel ? (marginLeft_len * availWidth / 100) : marginLeft_len;
    marginRight := marginRight_rel ? (marginRight_len * availWidth / 100) : marginRight_len;

    mt :=
      marginTop_auto ?
        0 :
        (marginTop_rel ? (marginTop_len * availWidth / 100) : marginTop_len);
    mb :=
      marginBottom_auto ?
        0 :
        (marginBottom_rel ? (marginBottom_len * availWidth / 100) : marginBottom_len);
    ml :=
      !marginLeft_auto ?
        marginLeft :
        (blockWidth_auto ?
          0 :
          (marginRight_auto ? (marginWidth / 2) : (marginWidth - marginRight)));
    mr :=
      !marginRight_auto && (blockWidth_auto || marginLeft_auto) ?
        marginRight :
        (blockWidth_auto ?
          0 :
          (marginLeft_auto ? (marginWidth / 2) : (marginWidth - marginLeft)));

    frameWidth := ml + mr + boundWidth;
    frameHeight  := mt + mb + boundHeight;

    computedWidth :=
      is_root ?
        screenWidth :
        (blockWidth_auto ?
          ((intrinsMinWidth < availWidth ? availWidth : intrinsMinWidth) - frameWidth) :
          intrinsWidth);
  }
}

class BlockFlow (FrameFlow) : BaseFlow {
  children {
    flow : [BaseFlow];
  }
  attributes {
    // XXX: Rendering
    //input fragment: &Fragment;

    output innerWidth : int;
    output innerHeight : int;

    output innerMinWidth : int;
    output innerPrefWidth : int;
  }
  evaluation {
    loop flow {
      innerHeight := fold 0 .. self$-.innerHeight + flow$i.totalHeight;
      innerWidth := fold 0 .. self$-.innerWidth + flow$i.totalWidth;

      innerMinWidth :=
        fold intrinsWidth ..
          self$-.innerMinWidth < flow$i.intrinsMinWidth ?
            flow$i.intrinsMinWidth :
            self$-.innerMinWidth;
      innerPrefWidth :=
        fold intrinsWidth ..
          self$-.innerPrefWidth < flow$i.intrinsPrefWidth ?
            flow$i.intrinsPrefWidth :
            self$-.innerPrefWidth;

      flow.bottom := fold pt + bt .. flow$-.bottom + flow$i.totalHeight;
      flow.right := flow$i.totalWidth + pl + bl;

      flow.relX := flow$i.right - flow$i.totalWidth;
      flow.relY := flow$i.bottom - flow$i.totalHeight;

      flow.absX := flow$i.relX + absX + ml;
      flow.absY := flow$i.relY + absY + mt;

      flow.availWidth := computedWidth;

      // XXX: Rendering
      //display_list := fold makeList .. merge_lists(self$-.display_list, flow$i.display_list);
      //makeLists := fold 0 .. merge_lists(display_list, flow$i.display_list) + flow$i.render;
    }

    intrinsMinWidth := innerMinWidth + frameWidth;
    intrinsPrefWidth := (intrinsWidth == 0 ? innerPrefWidth : intrinsWidth) + frameWidth;

    boxX := relX + ml;
    boxY := relY + mt;

    boxWidth :=  is_root ? screenWidth : computedWidth + boundWidth;
    boxHeight := (intrinsHeight == 0 ? innerHeight : intrinsHeight) + boundHeight;

    totalWidth := boxWidth + ml + mr;
    totalHeight := boxHeight + mt + mb;

    // XXX: Rendering
    // Adds items to display list layering from bottom up. In this case background
    // comes before border.
    //display_list := new_display_list();
    //makeList := add_border(add_background(new_display_list(), fragment, absX + ml,
    //                                   absY + mt, boxWidth, boxHeight),
    //                    fragment, absX + ml, absY + mt, boxWidth, boxHeight, bt, br, bb, bl);
    //render := addBackground(display_list, fragment, absX + ml, absY + mt, boxWidth, boxHeight) +
    //            addBorder(display_list, fragment, absX + ml, absY + mt, boxWidth, boxHeight, bt, br, bb, bl);
  }
}

class ImageFlow (FrameFlow) : BaseFlow {
    attributes {
        // Dimensions of raw image
        input imageWidth : int;
        input imageHeight : int;
    }
    evaluation {
        boxX := relX + ml;
        boxY := relY + mt;

        boxWidth := (intrinsWidth == 0 ? imageWidth : intrinsWidth) + boundWidth;
        boxHeight := (intrinsHeight == 0 ? imageHeight : intrinsHeight) + boundHeight;

        totalWidth := boxWidth + ml + mr;
        totalHeight := boxHeight + mt + mb;
    }
}

class InlineFlow : BaseFlow {
  children {
    text : [InlineBox];
  }
  attributes {
    output topline : int;
    output baseline : int;
    //output baselineLast : [int];
  }
  evaluation {
    boxWidth := availWidth;
    boxX := relX;
    boxY := relY;
    intrinsPrefWidth := 0;
    intrinsMinWidth := 0;
    totalHeight := boxHeight;
    totalWidth := boxWidth;

    // XXX: The 'by' annotation on a loop is an undocumented hold-over.
    loop text /*by split_to_width(text$-.lineWidth, text$i.newline)*/ {
      text.newline :=
        fold true .. (text$i.inlineWidth > text$-.lineWidth) || text$i.linebreak;

      text.lineWidth :=
        fold availWidth .. text$i.newline ? availWidth : (text$-.lineWidth - text$i.inlineWidth);

      // XXX: This attribute is apparently a _mutable_ list of position/dimension values.
      //text.topline := fold EmptyList() ..
      //                  text$i.newline ?
      //                    append(text$-.topline, text$i.inlineAscent) :
      //                    modifyLast(text$-.topline, max(getLast(text$-.topline), text$i.inlineAscent));
      text.topline :=
        fold 0 .. text$i.newline ? (text$-.topline + text$i.inlineAscent) : text$-.topline;

      // XXX: This attribute is apparently a _mutable_ list of position/dimension values.
      //text.baseline := fold topline .. text$i.newline ? text$-.baseline : butFirst(text$-.baseline);
      text.baseline := fold topline .. text$i.newline ? text$-.baseline : text$i.topline;
    }

    topline := text$$.topline;
    baseline := text$$.baseline;

    loop text {
      text.right :=
        fold 0 .. text$i.newline ? text$i.inlineWidth : (text$-.right + text$i.inlineWidth);
      text.top :=
        fold 0 .. text$i.newline ? (text$-.top + text$i.lineHeight) : text$-.top;

      text.posX := absX + text$i.right - text$i.inlineWidth;
      text.posY := absY + text$i.top + text$i.baseline - text$i.inlineAscent;

      text.lineHeight :=
        fold 0 ..
          text$i.newline ?
            text$i.inlineHeight :
            (text$-.lineHeight < text$i.inlineHeight ? text$i.inlineHeight : text$-.lineHeight);

      boxHeight := fold 0 .. self$-.boxHeight + text$i.lineHeight;

      // XXX: Rendering
      //display_list := fold new_display_list() ..
      //                  add_text_fragment(self$-.display_list, text$i.fragSpecific, text$i.fragStyle,
      //                                    text$i.fragNode, text$i.posX, text$i.posY,
      //                                    text$i.lineWidth, text$i.lineHeight);
    }
  }
}

class InlineText : InlineBox { }
