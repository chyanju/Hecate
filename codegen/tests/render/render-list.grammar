// run with: run.rkt --root Document fuse codegen/tests/render/render-list.grammar

traversal fuse {
    case CDocument {
        ??; iterate PageList0 { ??; recur PageList0; ??; } ??;
        ??; iterate PageList { ??; recur PageList; ??; } ??;
    }
    case CPage0 {
        ??; iterate HorizList { ??; recur HorizList; ??; } ??;
    }
    case CPage {
        ??; iterate HorizList { ??; recur HorizList; ??; } ??;
    }

    case CHorizontalContainer0 {
        ??; iterate ElementList { ??; recur ElementList; ??; } ??;
    }
    case CHorizontalContainer {
        ??; iterate ElementList { ??; recur ElementList; ??; } ??;
    }
    case CGenericElement0 {
        ??;
    }
    case CGenericElement {
        ??;
    }
    case CVerticalContainer0 {
        ??; iterate HorizList { ??; recur HorizList; ??; } ??;
    }
    case CVerticalContainer {
        ??; iterate HorizList { ??; recur HorizList; ??; } ??;
    }
}

trait Horizontal {
  rules {
    // setFont
    HorizList.ParentFontStyle := self.FontStyle1;
    
    // resolveRelative
    HorizList.PWidth := self.Width;
    
    // computeHeight
    self.Height := self.CurrY;
    
    // setPositions
    self.CurrX := self.PosX;
    self.CurrY := foldl self.PosY .. @{self.CurrY} + HorizList.Height;
    HorizList.PosX := self.CurrX;
    HorizList.PosY := @{self.CurrY};
  }
}

trait Data {
    rules {
        // setFont
        self.FontStyle1 :=
            if self.FontStyle0 == 0 - 1 then
                self.ParentFontStyle
            else
                self.FontStyle0;
        
        // resolveFlex

        // resolveRelative
        self.WidthRel := self.RelWidth * self.PWidth;

        self.Width :=
            if isFLEX(self.WMode) then
                self.WidthFlex
            else if isREL(self.WMode) then
                self.WidthRel
            else // ABS
                self.WidthAbs;
        
        // computeHeight
        // setPositions
    }
}

// ============================= //
// ========== Program ========== //
// ============================= //

interface Document {
    // model arguments to PageList.setFont
    input FontStyle : int;
}
class CDocument : Document {
    children {
        PageList0 : [Page0];
        PageList : [Page];
    }
    rules {
        PageList.PosX := 0;
        PageList.PosY := 0;
        PageList.ParentFontStyle := self.FontStyle;
    }
}

interface Page0 {
    input WidthAbs : int;
    input WMode : int;
    output MaxWidth : int;
    output Width : int;
}
class CPage0 : Page0 {
    children {
        HorizList : [HorizontalContainer0];
    }
    rules {
        self.MaxWidth := foldl 0 .. max(@{self.MaxWidth}, HorizList.Width);
        self.Width :=
            if isFLEX(self.WMode) then
                self.MaxWidth
            else
                self.WidthAbs;
    }
}

interface HorizontalContainer0 {
    input WidthAbs : int;
    input WMode : int;
    output AccumulatedWidth : int;
    output Width : int;
}
class CHorizontalContainer0 : HorizontalContainer0 {
    children {
        ElementList : [Element0];
    }
    rules {
        self.AccumulatedWidth := foldl 0 .. @{self.AccumulatedWidth} + ElementList.Width;
        self.Width :=
            if isFLEX(self.WMode) then
                self.AccumulatedWidth
            else
                self.WidthAbs;
    }
}

interface Element0 {
    input WidthAbs : int;
    input WMode : int;
    output MaxWidth : int;
    output Width : int;
}
class CGenericElement0 : Element0 {
    children {}
    rules {
        self.MaxWidth := -1; // not used
        self.Width :=
            if isFLEX(self.WMode) then
                panic()
            else
                self.WidthAbs;
    }
}
class CVerticalContainer0 : Element0 {
    children {
        HorizList : [HorizontalContainer0];
    }
    rules {
        self.MaxWidth := foldl 0 .. max(@{self.MaxWidth}, HorizList.Width);
        self.Width :=
            if isFLEX(self.WMode) then
                self.MaxWidth
            else
                self.WidthAbs;
    }
}

interface Page {
    // setFont
    input FontStyle0 : int;
    output FontStyle1 : int;
    // args
    output ParentFontStyle : int;
    
    // resolveFlexWidths
    input WidthAbs : int;
    input WMode : int;
    output MaxWidth : int;
    output WidthFlex : int;
    
    // resolveRelativeWidths
    input RelWidth : int;
    output WidthRel : int;
    output Width : int;

     // computeHeights
    output Height : int;
    
    // setPositions
    output PosX : int;
    output PosY : int;
    output CurrX : int;
    output CurrY : int;
}

class CPage(Data, Horizontal) : Page {
    children {
        HorizList : [HorizontalContainer];
    }
    rules {
        // 1. setFont

        // 2. resolveFlexWidths
        self.MaxWidth := tunnel();
        self.WidthFlex := self.MaxWidth;
        self.WidthRel := if isREL(self.WMode) then panic() else -1;
        
        // 3. resolveRelativeWidths

        // 4. computeHeights:
        
        // 5. setPositions
    }
}

interface HorizontalContainer {
    // setFont
    input FontStyle0 : int;
    output FontStyle1 : int;
    // args
    output ParentFontStyle : int; 

    // resolveFlexWidths
    input WidthAbs : int;
    input WMode : int;
    output AccumulatedWidth : int;
    output WidthFlex : int;
    
    // resolveRelativeWidths
    input RelWidth : int;
    // args
    output WidthRel : int;
    output PWidth : int;
    output Width : int;
    
    // computeHeights
    output Height : int;
    output MaxHeight : int;

    // setPositions
    output PosX : int;
    output PosY : int;
    output CurrX : int;
    output CurrY : int;
}
class CHorizontalContainer(Data) : HorizontalContainer {
    children {
        ElementList : [Element];
    }
    rules {
        // 1. setFont
        ElementList.ParentFontStyle := self.FontStyle1;
        
        // 2. resolveFlexWidths
        self.AccumulatedWidth := tunnel();
        self.WidthFlex := self.AccumulatedWidth;
        
        // 3. resolveRelativeWidths
            
        // pass downwards
        ElementList.PWidth := self.Width;
        
        // 4. computeHeights
        self.MaxHeight := foldl 0 .. max(@{self.MaxHeight}, ElementList.Height);
        self.Height := self.MaxHeight;
        
        // 5. setPositions
        self.CurrX := foldl self.PosX .. @{self.CurrX} + ElementList.Width;
        self.CurrY := self.PosY;
        ElementList.PosX := @{self.CurrX};
        ElementList.PosY := self.CurrY;
    }
}

interface Element {
    // setFont
    input FontStyle0 : int;
    output FontStyle1 : int;
    // args
    output ParentFontStyle : int;
    
    // resolveFlexWidths
    input RelWidth : int;
    input WidthAbs : int;
    input WMode : int;
    output MaxWidth : int;
    output WidthFlex : int; 
    
    // resolveRelativeWidths
    output WidthRel : int; 
    output Width : int;
    // args
    output PWidth : int;
    
    // computeHeights
    output Height : int;
    
    // setPositions
    output PosX : int;
    output PosY : int;
    // args
    output CurrX : int; 
    output CurrY : int;
}
class CGenericElement(Data) : Element {
    children {}
    rules {
        // 1. setFont

        // 2. resolveFlexWidths
        self.MaxWidth := tunnel();
        self.WidthFlex := if isFLEX(self.WMode) then panic() else -1;

        // 3. resolveRelativeWidths

        // 4. computeHeights
        self.Height := evalHeight();
        
        // 5. setPositions
        self.CurrX := -1; // not used
        self.CurrY := -1; // not used
    }
}
class CVerticalContainer(Data, Horizontal) : Element {
    children {
        HorizList : [HorizontalContainer];
    }
    rules {
        // 1. setFont

        // 2. resolveFlexWidths
        self.MaxWidth := tunnel();
        self.WidthFlex := self.MaxWidth;
        
        // 3. resolveRelativeWidths

        // 4. computeHeights
        self.Height := self.CurrY;
        
        // 5. setPositions
    }
}
