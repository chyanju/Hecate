// 1. setFont
// 2. resolveFlexWidths
// 3. resolveRelativeWidths
// 4. computeHeights
// 5. setPositions
// run with: run.rkt --root Document fuse codegen/tests/render/render.grammar


traversal fuse {
    case CDocument {
        ??;
        iterate PageList { ??; recur PageList; ??; }
        ??;
    }
    case CPage {
        ??;
        iterate HorizList { ??; recur HorizList; ??; }
        ??;
        iterate Next { ??; recur Next; ??; }
        ??;
    }
    case CHorizontalContainer {
        ??;
        iterate ElementList { ??; recur ElementList; ??; }
        ??;
        iterate Next { ??; recur Next; ??; }
        ??;
    }
    case CNormalElement {
        ??;
        iterate Next { ??; recur Next; ??; }
        ??;
    }
    case CVerticalContainer {
        ??;
        iterate HorizList { ??; recur HorizList; ??; }
        ??;
        iterate Next { ??; recur Next; ??; }
        ??;
    }
}

// ============================= //
// ========== Program ========== //
// ============================= //

interface Document {
    // model arguments to PageList.setFont
    input FontStyle : int;
}
class CDocument : Document {
    children {
        PageList : [Page];
    }
    rules {
        PageList.ParentFontStyle := self.FontStyle;
    }
}

interface Page {
    // setFont
    input FontStyle0 : int;
    output FontStyle1 : int;
    // args
    output ParentFontStyle : int;
    
    // resolveFlexWidths
    input WidthAbs : int;
    input WMode : int;
    output WidthFlex : int;
    
    // resolveRelativeWidths
    input RelWidth : int;
    output Width : int;

     // computeHeights
    output Height : int;
    
    // setPositions
    output PosX : int;
    output PosY : int;
}
class CPage : Page {
    children {
        HorizList : [HorizontalContainer];
        Next : [Page]; // 0 or 1
    }
    rules {
        // 1. setFont
        self.FontStyle1 :=
            if self.FontStyle0 == 0 - 1 then
                self.ParentFontStyle
            else
                self.FontStyle0;
        
        // pass function parameters rightwards
        Next.ParentFontStyle := self.ParentFontStyle;
        // pass function parameters downwards
        HorizList.ParentFontStyle := self.FontStyle1;

        // 2. resolveFlexWidths
        self.WidthFlex := [0]{ HorizList.MaxWidth : panic() };
        self.Width :=
            if isFLEX(self.WMode) then
                self.WidthFlex
            else if isREL(self.WMode) then
                panic() // Page cannot have relative width
            else // ABS
                self.WidthAbs;
        
        // 3. resolveRelativeWidths
        // pass downwards
        HorizList.PWidth := self.Width;

        // 4. computeHeights:
        self.Height := [0]{ HorizList.AggregatedHeight : panic() };
        
        // 5. setPositions
        self.PosX := 0;
        self.PosY := 0;
        // pass downwards
        HorizList.CurrX := self.PosX;
        HorizList.CurrY := self.PosY;
    }
}

interface HorizontalContainer {
    // setFont
    input FontStyle0 : int;
    output FontStyle1 : int;
    // args
    output ParentFontStyle : int; 

    // resolveFlexWidths
    input WidthAbs : int;
    input WMode : int;
    output WidthFlex : int;
    // output NextMaxWidth : int;
    // output MaxWidth : int; 
    input MaxWidth : int; 

    
    // resolveRelativeWidths
    input RelWidth : int;
    // args
    output WidthRel : int;
    output PWidth : int;
    output Width : int;
    
    // computeHeights
    output Height : int;
    output AggregatedHeight : int;

    // setPositions
    output PosX : int;
    output PosY : int;
    // args
    output CurrX : int;
    output CurrY : int;
}
class CHorizontalContainer : HorizontalContainer {
    children {
        ElementList : [Element];
        Next : [HorizontalContainer]; // 0 or 1
    }
    rules {
        // 1. setFont
        self.FontStyle1 :=
            if self.FontStyle0 == 0 - 1 then
                self.ParentFontStyle
            else
                self.FontStyle0;
        // pass rightwards
        Next.ParentFontStyle := self.ParentFontStyle;
        // pass downwards
        ElementList.ParentFontStyle := self.FontStyle1;
        
        // 2. resolveFlexWidths
        self.WidthFlex := [0]{ ElementList.AccumulatedWidth : panic() };    
        // self.NextMaxWidth := [0]{ Next.MaxWidth : default() };
        // self.MaxWidth := 
        //     if self.WidthNonRel > self.NextMaxWidth then
        //         self.WidthNonRel
        //     else
        //         self.NextMaxWidth;
        
        // 3. resolveRelativeWidths
        self.WidthRel := self.RelWidth * self.PWidth;
        self.Width :=
            if isFLEX(self.WMode) then
                self.WidthFlex
            else if isREL(self.WMode) then
                self.WidthRel
            else // ABS
                self.WidthAbs;
            
        // pass rightwards
        Next.PWidth := self.PWidth;
        // pass downwards
        ElementList.PWidth := self.Width;
        
        // 4. computeHeights
        self.Height := [0]{ ElementList.MaxHeight : panic() };
        self.AggregatedHeight := self.Height + [0]{ Next.AggregatedHeight : default() };
        
        // 5. setPositions
        self.PosX := self.CurrX;
        self.PosY := self.CurrY;
        // pass rightwards
        Next.CurrX := self.CurrX;
        Next.CurrY := self.CurrY + self.Height;
        // pass downwards
        ElementList.CurrX := self.CurrX;
        ElementList.CurrY := self.CurrY;
    }
}

interface Element {
    // setFont
    input FontStyle0 : int;
    output FontStyle1 : int;
    // args
    output ParentFontStyle : int;
    
    // resolveFlexWidths
    input RelWidth : int;
    input WidthAbs : int;
    input WMode : int;
    output WidthFlex : int; 
    // output WidthNonRel : int;
    input AccumulatedWidth : int;
    
    // resolveRelativeWidths
    output WidthRel : int; 
    output Width : int;
    // args
    output PWidth : int;
    
    // computeHeights
    input ElementType : int;
    output Height : int;
    output NextMaxHeight : int;
    output MaxHeight : int;
    
    // setPositions
    output PosX : int;
    output PosY : int;
    // args
    output CurrX : int; 
    output CurrY : int;
}
class CNormalElement : Element {
    children {
        Next : [Element]; // 0 or 1
    }
    rules {
        // 1. setFont
        self.FontStyle1 :=
            if self.FontStyle0 == 0 - 1 then
                self.ParentFontStyle
            else
                self.FontStyle0;
        // pass rightwards
        Next.ParentFontStyle := self.ParentFontStyle;

        // 2. resolveFlexWidths
        self.WidthFlex := -1; // not used
        // self.AccumulatedWidth := self.WidthNonRel + [0]{ Next.AccumulatedWidth : default() };

        // 3. resolveRelativeWidths
        self.WidthRel := self.RelWidth * self.PWidth;
        self.Width :=
            if isFLEX(self.WMode) then
                panic()
            else if isREL(self.WMode) then
                self.WidthRel
            else
                self.WidthAbs;
        // pass rightwards
        Next.PWidth := self.PWidth;

        // 4. computeHeights
        self.NextMaxHeight := [0]{ Next.MaxHeight : default() };
        self.MaxHeight :=
            if self.Height > self.NextMaxHeight then
                self.Height
            else
                self.NextMaxHeight;
        
        self.Height :=
            if isTextBox(self.ElementType) then
                computeHeights4TextBox( self.FontStyle1, self.Width )
            else if isList(self.ElementType) then
                computeHeights4List( self.FontStyle1, self.Width )
            else if isImage(self.ElementType) then
                computeHeights4Image( self.Width )
            else
                default();
        
        // 5. setPositions
        self.PosX := self.CurrX;
        self.PosY := self.CurrY;
        // pass rightwards
        Next.CurrX := self.CurrX + self.Width;
        Next.CurrY := self.CurrY;
    }
}
class CVerticalContainer : Element {
    children {
        HorizList : [HorizontalContainer];
        Next : [Element]; // 0 or 1
    }
    rules {
        // 1. setFont
        self.FontStyle1 :=
            if self.FontStyle0 == 0 - 1 then
                self.ParentFontStyle
            else
                self.FontStyle0;
        // pass rightwards
        Next.ParentFontStyle := self.ParentFontStyle;
        // pass downwards
        HorizList.ParentFontStyle := self.FontStyle1;

        // 2. resolveFlexWidths
        self.WidthFlex := [0]{ HorizList.MaxWidth : panic() };
        // self.AccumulatedWidth := self.WidthNonRel + [0]{ Next.AccumulatedWidth : default() };
        
        // 3. resolveRelativeWidths
        self.WidthRel := self.RelWidth * self.PWidth;
        self.Width := 
            if isFLEX(self.WMode) then
                self.WidthFlex
            else if isREL(self.WMode) then
                self.WidthRel
            else
                self.WidthAbs;

        // pass rightwards
        Next.PWidth := self.PWidth;
        // pass downwards
        HorizList.PWidth := self.Width;

        // 4. computeHeights
        self.NextMaxHeight := [0]{ Next.MaxHeight : default() };
        self.MaxHeight :=
            if self.Height > self.NextMaxHeight then
                self.Height
            else
                self.NextMaxHeight;
        self.Height := [0]{ HorizList.AggregatedHeight : panic() };
        
        // 5. setPositions
        self.PosX := self.CurrX;
        self.PosY := self.CurrY;
        // pass rightwards
        Next.CurrX := self.CurrX + self.Width;
        Next.CurrY := self.CurrY;
        // pass downwards
        HorizList.CurrX := self.CurrX;
        HorizList.CurrY := self.CurrY;
    }
}
